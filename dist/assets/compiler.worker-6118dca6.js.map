{"version":3,"file":"compiler.worker-6118dca6.js","sources":["../src/image-target/utils/cumsum.js","../src/image-target/tracker/extract.js","../src/image-target/tracker/extract-utils.js","../src/image-target/utils/images.js","../src/image-target/image-list.js","../src/image-target/compiler.worker.js"],"sourcesContent":["// fast 2D submatrix sum using cumulative sum algorithm\nclass Cumsum {\n  constructor(data, width, height) {\n    this.cumsum = [];\n    for (let j = 0; j < height; j++) {\n      this.cumsum.push([]);\n      for (let i = 0; i < width; i++) {\n        this.cumsum[j].push(0);\n      }\n    }\n\n    this.cumsum[0][0] = data[0];\n    for (let i = 1; i < width; i++) {\n      this.cumsum[0][i] = this.cumsum[0][i-1] + data[i];\n    }\n    for (let j = 1; j < height; j++) {\n      this.cumsum[j][0] = this.cumsum[j-1][0] + data[j*width];\n    }\n\n    for (let j = 1; j < height; j++) {\n      for (let i = 1; i < width; i++) {\n        this.cumsum[j][i] = data[j*width+i]\n                               + this.cumsum[j-1][i]\n                               + this.cumsum[j][i-1]\n                               - this.cumsum[j-1][i-1];\n      }\n    }\n  }\n\n  query(x1, y1, x2, y2) {\n    let ret = this.cumsum[y2][x2];\n    if (y1 > 0) ret -= this.cumsum[y1-1][x2];\n    if (x1 > 0) ret -= this.cumsum[y2][x1-1];\n    if (x1 > 0 && y1 > 0) ret += this.cumsum[y1-1][x1-1];\n    return ret;\n  }\n}\n\nexport {\n  Cumsum\n}\n","import {Cumsum} from '../utils/cumsum.js';\n\nconst SEARCH_SIZE1 = 10;\nconst SEARCH_SIZE2 = 2;\n\n//const TEMPLATE_SIZE = 22 // DEFAULT\nconst TEMPLATE_SIZE = 6;\nconst TEMPLATE_SD_THRESH = 5.0;\nconst MAX_SIM_THRESH = 0.95;\n\nconst MAX_THRESH = 0.9;\n//const MIN_THRESH = 0.55;\nconst MIN_THRESH = 0.2;\nconst SD_THRESH = 8.0;\nconst OCCUPANCY_SIZE = 24 * 2 / 3;\n\n/*\n * Input image is in grey format. the imageData array size is width * height. value range from 0-255\n * pixel value at row r and c = imageData[r * width + c]\n *\n * @param {Uint8Array} options.imageData\n * @param {int} options.width image width\n * @param {int} options.height image height\n */\nconst extract = (image) => {\n  const {data: imageData, width, height, scale} = image;\n\n  // Step 1 - filter out interesting points. Interesting points have strong pixel value changed across neighbours\n  const isPixelSelected = [width * height];\n  for (let i = 0; i < isPixelSelected.length; i++) isPixelSelected[i] = false;\n\n  // Step 1.1 consider a pixel at position (x, y). compute:\n  //   dx = ((data[x+1, y-1] - data[x-1, y-1]) + (data[x+1, y] - data[x-1, y]) + (data[x+1, y+1] - data[x-1, y-1])) / 256 / 3\n  //   dy = ((data[x+1, y+1] - data[x+1, y-1]) + (data[x, y+1] - data[x, y-1]) + (data[x-1, y+1] - data[x-1, y-1])) / 256 / 3\n  //   dValue =  sqrt(dx^2 + dy^2) / 2;\n  const dValue = new Float32Array(imageData.length);\n  for (let i = 0; i < width; i++) {\n    dValue[i] = -1;\n    dValue[width * (height-1) + i] = -1;\n  }\n  for (let j = 0; j < height; j++) {\n    dValue[j*width] = -1;\n    dValue[j*width + width-1] = -1;\n  }\n\n  for (let i = 1; i < width-1; i++) {\n    for (let j = 1; j < height-1; j++) {\n      let pos = i + width * j;\n\n      let dx = 0.0;\n      let dy = 0.0;\n      for (let k = -1; k <= 1; k++) {\n        dx += (imageData[pos + width*k + 1] - imageData[pos + width*k -1]);\n        dy += (imageData[pos + width + k] - imageData[pos - width + k]);\n      }\n      dx /= (3 * 256);\n      dy /= (3 * 256);\n      dValue[pos] = Math.sqrt( (dx * dx + dy * dy) / 2);\n    }\n  }\n\n  // Step 1.2 - select all pixel which is dValue largest than all its neighbour as \"potential\" candidate\n  //  the number of selected points is still too many, so we use the value to further filter (e.g. largest the dValue, the better)\n  const dValueHist = new Uint32Array(1000); // histogram of dvalue scaled to [0, 1000)\n  for (let i = 0; i < 1000; i++) dValueHist[i] = 0;\n  const neighbourOffsets = [-1, 1, -width, width];\n  let allCount = 0;\n  for (let i = 1; i < width-1; i++) {\n    for (let j = 1; j < height-1; j++) {\n      let pos = i + width * j;\n      let isMax = true;\n      for (let d = 0; d < neighbourOffsets.length; d++) {\n        if (dValue[pos] <= dValue[pos + neighbourOffsets[d]]) {\n          isMax = false;\n          break;\n        }\n      }\n      if (isMax) {\n        let k = Math.floor(dValue[pos] * 1000);\n        if (k > 999) k = 999; // k>999 should not happen if computaiton is correction\n        if (k < 0) k = 0; // k<0 should not happen if computaiton is correction\n        dValueHist[k] += 1;\n        allCount += 1;\n        isPixelSelected[pos] = true;\n      }\n    }\n  }\n\n  // reduce number of points according to dValue.\n  // actually, the whole Step 1. might be better to just sort the dvalues and pick the top (0.02 * width * height) points\n  const maxPoints = 0.02 * width * height;\n  let k = 999;\n  let filteredCount = 0;\n  while (k >= 0) {\n    filteredCount += dValueHist[k];\n    if (filteredCount > maxPoints) break;\n    k--;\n  }\n\n  //console.log(\"image size: \", width * height);\n  //console.log(\"extracted featues: \", allCount);\n  //console.log(\"filtered featues: \", filteredCount);\n\n  for (let i = 0; i < isPixelSelected.length; i++) {\n    if (isPixelSelected[i]) {\n      if (dValue[i] * 1000 < k) isPixelSelected[i] = false;\n    }\n  }\n\n  //console.log(\"selected count: \", isPixelSelected.reduce((a, b) => {return a + (b?1:0);}, 0));\n\n  // Step 2\n  // prebuild cumulative sum matrix for fast computation\n  const imageDataSqr = [];\n  for (let i = 0; i < imageData.length; i++) {\n    imageDataSqr[i] = imageData[i] * imageData[i];\n  }\n  const imageDataCumsum = new Cumsum(imageData, width, height);\n  const imageDataSqrCumsum = new Cumsum(imageDataSqr, width, height);\n\n  // holds the max similariliy value computed within SEARCH area of each pixel\n  //   idea: if there is high simliarity with another pixel in nearby area, then it's not a good feature point\n  //         next step is to find pixel with low similarity\n  const featureMap = new Float32Array(imageData.length);\n\n  for (let i = 0; i < width; i++) {\n    for (let j = 0; j < height; j++) {\n      const pos = j * width + i;\n      if (!isPixelSelected[pos]) {\n        featureMap[pos] = 1.0;\n        continue;\n      }\n\n      const vlen = _templateVar({image, cx: i, cy: j, sdThresh: TEMPLATE_SD_THRESH, imageDataCumsum, imageDataSqrCumsum});\n      if (vlen === null) {\n        featureMap[pos] = 1.0;\n        continue;\n      }\n\n      let max = -1.0;\n      for (let jj = -SEARCH_SIZE1; jj <= SEARCH_SIZE1; jj++) {\n        for (let ii = -SEARCH_SIZE1; ii <= SEARCH_SIZE1; ii++) {\n          if (ii * ii + jj * jj <= SEARCH_SIZE2 * SEARCH_SIZE2) continue;\n          const sim = _getSimilarity({image, cx: i+ii, cy: j+jj, vlen: vlen, tx: i, ty: j, imageDataCumsum, imageDataSqrCumsum});\n\n          if (sim === null) continue;\n\n          if (sim > max) {\n            max = sim;\n            if (max > MAX_SIM_THRESH) break;\n          }\n        }\n        if (max > MAX_SIM_THRESH) break;\n      }\n      featureMap[pos] = max;\n    }\n  }\n\n  // Step 2.2 select feature\n  const coords = _selectFeature({image, featureMap, templateSize: TEMPLATE_SIZE, searchSize: SEARCH_SIZE2, occSize: OCCUPANCY_SIZE, maxSimThresh: MAX_THRESH, minSimThresh: MIN_THRESH, sdThresh: SD_THRESH, imageDataCumsum, imageDataSqrCumsum});\n\n  return coords;\n}\n\nconst _selectFeature = (options) => {\n  let {image, featureMap, templateSize, searchSize, occSize, maxSimThresh, minSimThresh, sdThresh, imageDataCumsum, imageDataSqrCumsum} = options;\n  const {data: imageData, width, height, scale} = image;\n\n  //console.log(\"params: \", templateSize, templateSize, occSize, maxSimThresh, minSimThresh, sdThresh);\n\n  //occSize *= 2;\n  occSize = Math.floor(Math.min(image.width, image.height) / 10);\n\n  const divSize = (templateSize * 2 + 1) * 3;\n  const xDiv = Math.floor(width / divSize);\n  const yDiv = Math.floor(height / divSize);\n\n  let maxFeatureNum = Math.floor(width / occSize) * Math.floor(height / occSize) + xDiv * yDiv;\n  //console.log(\"max feature num: \", maxFeatureNum);\n\n  const coords = [];\n  const image2 = new Float32Array(imageData.length);\n  for (let i = 0; i < image2.length; i++) {\n    image2[i] = featureMap[i];\n  }\n\n  let num = 0;\n  while (num < maxFeatureNum) {\n    let minSim = maxSimThresh;\n    let cx = -1;\n    let cy = -1;\n    for (let j = 0; j < height; j++) {\n      for (let i = 0; i < width; i++) {\n        if (image2[j*width+i] < minSim) {\n          minSim = image2[j*width+i];\n          cx = i;\n          cy = j;\n        }\n      }\n    }\n    if (cx === -1) break;\n\n    const vlen = _templateVar({image, cx: cx, cy: cy, sdThresh: 0, imageDataCumsum, imageDataSqrCumsum});\n    if (vlen === null) {\n      image2[ cy * width + cx ] = 1.0;\n      continue;\n    }\n    if (vlen / (templateSize * 2 + 1) < sdThresh) {\n      image2[ cy * width + cx ] = 1.0;\n      continue;\n    }\n\n    let min = 1.0;\n    let max = -1.0;\n\n    for (let j = -searchSize; j <= searchSize; j++) {\n      for (let i = -searchSize; i <= searchSize; i++) {\n        if (i*i + j*j > searchSize * searchSize) continue;\n        if (i === 0 && j === 0) continue;\n\n        const sim = _getSimilarity({image, vlen, cx: cx+i, cy: cy+j, tx: cx, ty:cy, imageDataCumsum, imageDataSqrCumsum});\n        if (sim === null) continue;\n\n        if (sim < min) {\n          min = sim;\n          if (min < minSimThresh && min < minSim) break;\n        }\n        if (sim > max) {\n          max = sim;\n          if (max > 0.99) break;\n        }\n      }\n      if( (min < minSimThresh && min < minSim) || max > 0.99 ) break;\n    }\n\n    if( (min < minSimThresh && min < minSim) || max > 0.99 ) {\n        image2[ cy * width + cx ] = 1.0;\n        continue;\n    }\n\n    coords.push({x: cx, y: cy});\n    //coords.push({\n      //mx: 1.0 * cx / scale,\n      //my: 1.0 * (height - cy) / scale,\n    //})\n\n    num += 1;\n    //console.log(num, '(', cx, ',', cy, ')', minSim, 'min = ', min, 'max = ', max, 'sd = ', vlen/(templateSize*2+1));\n\n    // no other feature points within occSize square\n    for (let j = -occSize; j <= occSize; j++) {\n      for (let i = -occSize; i <= occSize; i++) {\n        if (cy + j < 0 || cy + j >= height || cx + i < 0 || cx + i >= width) continue;\n        image2[ (cy+j)*width + (cx+i) ] = 1.0;\n      }\n    }\n  }\n  return coords;\n}\n\n// compute variances of the pixels, centered at (cx, cy)\nconst _templateVar = ({image, cx, cy, sdThresh, imageDataCumsum, imageDataSqrCumsum}) => {\n  if (cx - TEMPLATE_SIZE < 0 || cx + TEMPLATE_SIZE >= image.width) return null;\n  if (cy - TEMPLATE_SIZE < 0 || cy + TEMPLATE_SIZE >= image.height) return null;\n\n  const templateWidth = 2 * TEMPLATE_SIZE + 1;\n  const nPixels = templateWidth * templateWidth;\n\n  let average = imageDataCumsum.query(cx - TEMPLATE_SIZE, cy - TEMPLATE_SIZE, cx + TEMPLATE_SIZE, cy+TEMPLATE_SIZE);\n  average /= nPixels;\n\n  //v = sum((pixel_i - avg)^2) for all pixel i within the template\n  //  = sum(pixel_i^2) - sum(2 * avg * pixel_i) + sum(avg^avg)\n\n  let vlen = imageDataSqrCumsum.query(cx - TEMPLATE_SIZE, cy - TEMPLATE_SIZE, cx + TEMPLATE_SIZE, cy+TEMPLATE_SIZE);\n  vlen -= 2 * average * imageDataCumsum.query(cx - TEMPLATE_SIZE, cy - TEMPLATE_SIZE, cx + TEMPLATE_SIZE, cy+TEMPLATE_SIZE);\n  vlen += nPixels * average * average;\n\n  if (vlen / nPixels < sdThresh * sdThresh) return null;\n  vlen = Math.sqrt(vlen);\n  return vlen;\n}\n\nconst _getSimilarity = (options) => {\n  const {image, cx, cy, vlen, tx, ty, imageDataCumsum, imageDataSqrCumsum} = options;\n  const {data: imageData, width, height} = image;\n  const templateSize = TEMPLATE_SIZE;\n\n  if (cx - templateSize < 0 || cx + templateSize >= width) return null;\n  if (cy - templateSize < 0 || cy + templateSize >= height) return null;\n\n  const templateWidth = 2 * templateSize + 1;\n\n  let sx = imageDataCumsum.query(cx-templateSize, cy-templateSize, cx+templateSize, cy+templateSize);\n  let sxx = imageDataSqrCumsum.query(cx-templateSize, cy-templateSize, cx+templateSize, cy+templateSize);\n  let sxy = 0;\n\n  // !! This loop is the performance bottleneck. Use moving pointers to optimize\n  //\n  //   for (let i = cx - templateSize, i2 = tx - templateSize; i <= cx + templateSize; i++, i2++) {\n  //     for (let j = cy - templateSize, j2 = ty - templateSize; j <= cy + templateSize; j++, j2++) {\n  //       sxy += imageData[j*width + i] * imageData[j2*width + i2];\n  //     }\n  //   }\n  //\n  let p1 = (cy-templateSize) * width + (cx-templateSize);\n  let p2 = (ty-templateSize) * width + (tx-templateSize);\n  let nextRowOffset = width - templateWidth;\n  for (let j = 0; j < templateWidth; j++) {\n    for (let i = 0; i < templateWidth; i++) {\n      sxy += imageData[p1] * imageData[p2];\n      p1 +=1;\n      p2 +=1;\n    }\n    p1 += nextRowOffset;\n    p2 += nextRowOffset;\n  }\n\n  let templateAverage = imageDataCumsum.query(tx-templateSize, ty-templateSize, tx+templateSize, ty+templateSize);\n  templateAverage /= templateWidth * templateWidth;\n  sxy -= templateAverage * sx;\n\n  let vlen2 = sxx - sx*sx / (templateWidth * templateWidth);\n  if (vlen2 == 0) return null;\n  vlen2 = Math.sqrt(vlen2);\n\n  // covariance between template and current pixel\n  const sim = 1.0 * sxy / (vlen * vlen2);\n  return sim;\n}\n\nexport {\n  extract\n};\n","import { extract } from './extract.js';\n\nexport const extractTrackingFeatures = (imageList, doneCallback) => {\n  const featureSets = [];\n  for (let i = 0; i < imageList.length; i++) {\n    const image = imageList[i];\n    const points = extract(image);\n\n    const featureSet = {\n      data: image.data,\n      scale: image.scale,\n      width: image.width,\n      height: image.height,\n      points,\n    };\n    featureSets.push(featureSet);\n\n    doneCallback(i);\n  }\n  return featureSets;\n}\n","// simpler version of upsampling. better performance\nconst _upsampleBilinear = ({image, padOneWidth, padOneHeight}) => {\n  const {width, height, data} = image;\n  const dstWidth = image.width * 2 + (padOneWidth?1:0);\n  const dstHeight = image.height * 2 + (padOneHeight?1:0);\n  const temp = new Float32Array(dstWidth * dstHeight);\n\n  for (let i = 0; i < width; i++) {\n    for (let j = 0; j < height; j++) {\n      const v = 0.25 * data[j * width + i];\n      const ii = Math.floor(i/2);\n      const jj = Math.floor(j/2);\n      const pos = Math.floor(j/2) * dstWidth + Math.floor(i/2);\n      temp[pos] += v;\n      temp[pos+1] += v;\n      temp[pos+dstWidth] += v;\n      temp[pos+dstWidth+1] += v;\n    }\n  }\n  return {data: temp, width: dstWidth, height: dstHeight};\n}\n\n// artoolkit version. slower. is it necessary?\nconst upsampleBilinear = ({image, padOneWidth, padOneHeight}) => {\n  const {width, height, data} = image;\n\n  const dstWidth = image.width * 2 + (padOneWidth?1:0);\n  const dstHeight = image.height * 2 + (padOneHeight?1:0);\n\n  const temp = new Float32Array(dstWidth * dstHeight);\n  for (let i = 0; i < dstWidth; i++) {\n    const si = 0.5 * i - 0.25;\n    let si0 = Math.floor(si);\n    let si1 = Math.ceil(si);\n    if (si0 < 0) si0 = 0; // border\n    if (si1 >= width) si1 = width - 1; // border\n\n    for (let j = 0; j < dstHeight; j++) {\n      const sj = 0.5 * j - 0.25;\n      let sj0 = Math.floor(sj);\n      let sj1 = Math.ceil(sj);\n      if (sj0 < 0) sj0 = 0; // border\n      if (sj1 >= height) sj1 = height - 1; //border\n\n      const value = (si1 - si) * (sj1 - sj) * data[ sj0 * width + si0 ] +\n                    (si1 - si) * (sj - sj0) * data[ sj1 * width + si0 ] +\n                    (si - si0) * (sj1 - sj) * data[ sj0 * width + si1 ] +\n                    (si - si0) * (sj - sj0) * data[ sj1 * width + si1 ];\n\n      temp[j * dstWidth + i] = value;\n    }\n  }\n\n  return {data: temp, width: dstWidth, height: dstHeight};\n}\n\nconst downsampleBilinear = ({image}) => {\n  const {data, width, height} = image;\n\n  const dstWidth = Math.floor(width / 2);\n  const dstHeight = Math.floor(height / 2);\n\n  const temp = new Float32Array(dstWidth * dstHeight);\n  const offsets = [0, 1, width, width+1];\n\n  for (let j = 0; j < dstHeight; j++) {\n    for (let i = 0; i < dstWidth; i++) {\n      let srcPos = j*2 * width + i*2;\n      let value = 0.0;\n      for (let d = 0; d < offsets.length; d++) {\n        value += data[srcPos+ offsets[d]];\n      }\n      value *= 0.25;\n      temp[j*dstWidth+i] = value;\n    }\n  }\n  return {data: temp, width: dstWidth, height: dstHeight};\n}\n\nconst resize = ({image, ratio}) => {\n  const width = Math.round(image.width * ratio);\n  const height = Math.round(image.height * ratio);\n\n  //const imageData = new Float32Array(width * height);\n  const imageData = new Uint8Array(width * height);\n  for (let i = 0; i < width; i++) {\n    let si1 = Math.round(1.0 * i / ratio);\n    let si2 = Math.round(1.0 * (i+1) / ratio) - 1;\n    if (si2 >= image.width) si2 = image.width - 1;\n\n    for (let j = 0; j < height; j++) {\n      let sj1 = Math.round(1.0 * j / ratio);\n      let sj2 = Math.round(1.0 * (j+1) / ratio) - 1;\n      if (sj2 >= image.height) sj2 = image.height - 1;\n\n      let sum = 0;\n      let count = 0;\n      for (let ii = si1; ii <= si2; ii++) {\n        for (let jj = sj1; jj <= sj2; jj++) {\n          sum += (1.0 * image.data[jj * image.width + ii]);\n          count += 1;\n        }\n      }\n      imageData[j * width + i] = Math.floor(sum / count);\n    }\n  }\n  return {data: imageData, width: width, height: height};\n}\n\nexport {\n  downsampleBilinear,\n  upsampleBilinear,\n  resize,\n}\n\n","import {resize} from \"./utils/images.js\";\n\nconst MIN_IMAGE_PIXEL_SIZE = 100;\n\n// Build a list of image {data, width, height, scale} with different scales\nconst buildImageList = (inputImage) => {\n  const minScale = MIN_IMAGE_PIXEL_SIZE / Math.min(inputImage.width, inputImage.height);\n\n  const scaleList = [];\n  let c = minScale;\n  while (true) {\n    scaleList.push(c);\n    c *= Math.pow(2.0, 1.0/3.0);\n    if (c >= 0.95) {\n      c = 1;\n      break;\n    }\n  }\n  scaleList.push(c);\n  scaleList.reverse();\n\n  const imageList = [];\n  for (let i = 0; i < scaleList.length; i++) {\n    const w = inputImage.width * scaleList[i];\n    const h = inputImage.height * scaleList[i];\n    imageList.push(Object.assign(resize({image: inputImage, ratio: scaleList[i]}), {scale: scaleList[i]}));\n  }\n  return imageList;\n}\n\nconst buildTrackingImageList = (inputImage) => {\n  const minDimension = Math.min(inputImage.width, inputImage.height);\n  const scaleList = [];\n  const imageList = [];\n  scaleList.push( 256.0 / minDimension);\n  scaleList.push( 128.0 / minDimension);\n  for (let i = 0; i < scaleList.length; i++) {\n    imageList.push(Object.assign(resize({image: inputImage, ratio: scaleList[i]}), {scale: scaleList[i]}));\n  }\n  return imageList;\n}\n\nexport {\n  buildImageList,\n  buildTrackingImageList\n}\n","import { extractTrackingFeatures } from './tracker/extract-utils.js';\nimport { buildTrackingImageList } from './image-list.js';\n\nonmessage = (msg) => {\n  const { data } = msg;\n  if (data.type === 'compile') {\n    //console.log(\"worker compile...\");\n    const { targetImages } = data;\n    const percentPerImage = 100.0 / targetImages.length;\n    let percent = 0.0;\n    const list = [];\n    for (let i = 0; i < targetImages.length; i++) {\n      const targetImage = targetImages[i];\n      const imageList = buildTrackingImageList(targetImage);\n      const percentPerAction = percentPerImage / imageList.length;\n\n      //console.log(\"compiling tracking...\", i);\n      const trackingData = extractTrackingFeatures(imageList, (index) => {\n        //console.log(\"done tracking\", i, index);\n        percent += percentPerAction\n        postMessage({ type: 'progress', percent });\n      });\n      list.push(trackingData);\n    }\n    postMessage({\n      type: 'compileDone',\n      list,\n    });\n  }\n};\n"],"names":["Cumsum","data","width","height","j","i","x1","y1","x2","y2","ret","SEARCH_SIZE1","SEARCH_SIZE2","TEMPLATE_SIZE","TEMPLATE_SD_THRESH","MAX_SIM_THRESH","MAX_THRESH","MIN_THRESH","SD_THRESH","OCCUPANCY_SIZE","extract","image","imageData","scale","isPixelSelected","dValue","pos","dx","dy","k","dValueHist","neighbourOffsets","isMax","d","maxPoints","filteredCount","imageDataSqr","imageDataCumsum","imageDataSqrCumsum","featureMap","vlen","_templateVar","max","jj","ii","sim","_getSimilarity","_selectFeature","options","templateSize","searchSize","occSize","maxSimThresh","minSimThresh","sdThresh","divSize","xDiv","yDiv","maxFeatureNum","coords","image2","num","minSim","cx","cy","min","templateWidth","nPixels","average","tx","ty","sx","sxx","sxy","p1","p2","nextRowOffset","templateAverage","vlen2","extractTrackingFeatures","imageList","doneCallback","featureSets","points","featureSet","resize","ratio","si1","si2","sj1","sj2","sum","count","buildTrackingImageList","inputImage","minDimension","scaleList","msg","targetImages","percentPerImage","percent","list","targetImage","percentPerAction","trackingData","index"],"mappings":"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"}